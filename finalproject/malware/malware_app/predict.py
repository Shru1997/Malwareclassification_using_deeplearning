import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pyplot as plt #plotting
import cv2 # Image reading and preprocessing
import keras # To Build our model
from keras.layers import Conv2D , MaxPooling2D # Getting our Layers for ConvNet
from keras.optimizers import SGD # Our Optimizer, but we will be using adam.
from keras.models import Sequential # We will be using Sequential as our model
from keras.layers import Dropout, Dense , Flatten # Our other layers
from keras.utils import to_categorical # to make data categorized like converting data into arrays
from sklearn.model_selection import train_test_split # Splitting the data into training and testing
from matplotlib.image import imread #To read the image
import os
import seaborn as sns
import tensorflow as tf
import numpy

def process():
    model = tf.keras.models.load_model(os.getcwd()+'/malimg_model.h5')
    class_dir_list = ['Adialer.C', 'Agent.FYI', 'Allaple.A', 'Allaple.L', 'Alueron.gen!J', 'Autorun.K', 'C2LOP.P', 'C2LOP.gen!g', 'Dialplatform.B', 'Dontovo.A', 'Fakerean', 'Instantaccess', 'Lolyda.AA1', 'Lolyda.AA2', 'Lolyda.AA3', 'Lolyda.AT', 'Malex.gen!J', 'Obfuscator.AD', 'Rbot!gen', 'Skintrim.N', 'Swizzor.gen!E', 'Swizzor.gen!I', 'VB.AT', 'Wintrim.BX', 'Yuner.A']
    import cv2
    def prepare(filepath):
        IMG_SIZE = 150
        img_array = cv2.imread(path+'/'+filepath[0])
        new_array = cv2.resize(img_array, (IMG_SIZE,IMG_SIZE))
        return new_array.reshape(-1, IMG_SIZE, IMG_SIZE, 3)

    def to_img(mal_path):
        import os
        import imageio
        import array
        import numpy
        f = open(mal_path,'rb')
        ln = os.path.getsize(mal_path)
        width = 512
        rem = ln%width
        a = array.array("B")
        a.fromfile(f,ln-rem)
        f.close()
        g = numpy.reshape(a,(int(len(a)/width),width))
        g = numpy.uint8(g)  
        img_path = mal_path+'.png'
        imageio.imwrite(img_path,g)
        return img_path

    def detect_mal_from_binery(mal_path) :
        class_dir_list = ['Adialer.C', 'Agent.FYI', 'Allaple.A', 'Allaple.L', 'Alueron.gen!J', 'Autorun.K', 'C2LOP.P', 'C2LOP.gen!g', 'Dialplatform.B', 'Dontovo.A', 'Fakerean', 'Instantaccess', 'Lolyda.AA1', 'Lolyda.AA2', 'Lolyda.AA3', 'Lolyda.AT', 'Malex.gen!J', 'Obfuscator.AD', 'Rbot!gen', 'Skintrim.N', 'Swizzor.gen!E', 'Swizzor.gen!I', 'VB.AT', 'Wintrim.BX', 'Yuner.A']
        mal_img = to_img(mal_path)
        predict_mal_from_img(mal_img)
  
    def predict_mal_from_img(mal_img) :
        import ntpath
        prepared_mal_img = prepare(mal_img)
        predicted_mal_class = model.predict([prepared_mal_img])
        print(predicted_mal_class)
        intg = get_class_index(predicted_mal_class)
        print(intg)
        head, tail = ntpath.split(mal_img[0])
        mal_name = tail or ntpath.basename(mal_img[0])
        #print(mal_name+' ======> '+class_dir_list[intg])
        return class_dir_list[intg]

    def get_class_index(predicted_mal_class) : 
        return [np.where(r==1)[0][0] for r in predicted_mal_class][0]

    path=os.getcwd()+'\\static\\img'
    img=os.listdir(path)

    a=predict_mal_from_img(img)
    return a
    
